# Backend социальной сети High load
#### ДЗ по курсу Otus Highload Architect

## Инструкция по локальному запуску приложения
До запуска необходимо установить docker-compose и Postman если они не были устновлены ранее.

#### Для запуска приложения локально:
1. Клонируйте репозиторий
2. Выполните docker-compose up -d в корне репозитория
3. Убедитесь, что контейнеры high-load-social-network-backend и mysqldb запущены

#### Для проверки сервисов регистрации, профиля пользователя, друзей и постов:

1. В Postman импортируйте коллекцию, которая находится в папке postman в корне репозитория
2. Запустите коллекцию либо отдельные запросы
3. Убедитесь, что все запущенные запросы были выполнены

#### Для проверки сервиса диалогов:

1. Выберите любой клиент, который поддерживает websocket и базовую аутентификацию
2. В коллекции Postman запустите следующие запросы на создание пользователей, если Вы не делали этого ранее (см. выше) 
    - "Registration user 1", 
    - "Registration user 2 right"
3. В клиенте создайте подключение для каждого пользователя, используя следующие url:
    - ws://iivanov:12345@localhost:8080/high-load/dialog/ppetrov
    - ws://ppetrov:54321@localhost:8080/high-load/dialog/iivanov<br />
   В случае успешного подключения обоих пользователей диалог между пользователями ppetrov и iivanov можно считать созданным и переходить к следующему пункту
4. Отправьте несколько сообщений с текстовым содержимым от каждого пользователя, убедитесь, что как отправленные, так и полученные сообщения имеют следующий формат:<br />
    {"time" : "2023-01-01 00:00:00.0", "sender" : "iivanov", "content" : "Hello"}
5. Прервите соединение одного из пользователей, а затем подключите его снова. 
   Убедитесь, что после возобновления соединения в клиенте отразились все сообщения, полученные пользователем ранее.
   
    
## Архитектура

###Хранение данных

Используется СУБД MySQL. В базовом варианте развернуты три инстанса:
- mysql_s_0 - хранятся данные сервисов кроме сервиса диалога
- mysql_s_1 - шард №1 для хранения данных сервиса диалогов
- mysql_s_2 - шард №2 для хранения данных сервиса диалогов

Имя БД в каждом инстансе - social_network.<br />
Количество инстансов может быть увеличено с целью добавления шарда или реплики.<br />
Для проксирования SQL-запросов используется ProxySQL.

####Шардирование данных сервиса диалогов

Данные диалогов пользователей хранятся в таблице user_dialog, шардированной и партиционированной по полю v_bucket.
Значение поля v_bucket представляет собой результат вычисления хэш-функции от значения поля dialog_id (идентификатора диалога).
Все диалоги разделяются на 256 виртуальных бакетов. Данные одного диалога относятся к одному бакету и хранятся на одном шарде.
В базовом варианте данные диалогов разделены между шардами следующим образом:
- шард №1 - бакеты с 0 по 127
- шард №2 - бакеты с 128 по 255
Правила разделения SQL-запросов по описанному принципу определены в конфигурации ProxySQL.

Таблица user_dialog партиционирована по полю v_bucket с целью оптимизации запросов на выборку и удаление данных при решардинге, 
а также запросов, направляемых к таблице в процессе взаимодействия пользователей с сервисом диалогов.

При необходимости переноса данных отдельных бакетов на другой шард необходимо следующее:
1. Развернуть новый инстанс MySQL в кластере, зарегистрировать его в ProxySQL
2. Определить новый принцип распределения бакетов между шардами
3. Создать на новом шарде БД social_network и таблицу user_dialog, аналогичную находящимся на других шардах, с количеством партиций по количеству бакетов, которые предполагается хранить на этом шарде
4. В ProxySQL изменить старые и добавить новые правила разделения SQL-запросов в соответствии с новым принципом распределения бакетов
5. В ProxySQL настроить зеркалирование запросов на запись на шард, с которого переносятся данные выбранных бакетов, и шард, на который они переносятся
6. Переместить данные выбранных для переноса бакетов на новый шард
7. В ProxySQL отключить зеркалирование запросов на запись на шард, с которого были перенесены данные выбранных бакетов
8. Очистить партиции выбранных бакетов на шарде, с которого они были перенесены (truncate), уменьшить количество партиций
9. Убедиться, что распределение SQL-запросов между шардами осуществляется в соответствии с новым принципом распределения бакетов

Решардинг по приведенной схеме может осуществляется как с целью более равномерного распределения общего объема данных диалогов пользователей между шардами, 
так и предотвращения неравномерного распределения данных в следствие повышенной активности отдельных пользователей (эффект Леди Гаги).

###Кэширование данных

#### Ленты постов

Пользователи могут создавать, редактировать и удалять посты. Пост представляет собой текстовое сообщение длиной не более 1000 символов.

Пользователи могут просматривать посты своих друзей. Для этого каждый пост пользователя добавляется в летну постов его друзей (подписчиков). 
Список подписчиков для каждого отдельного поста определяется на момент публикации на основании данных таблицы user_friend.
Списки подписчиков для каждого отдельного поста хранятся в таблице user_post_sending и используются для формирования ленты постов пользователей.

Лента постов для каждого пользователя хранится в инстансе Redis в виде sorted set, TTL ключа неограничено.
В качестве ключа используется id пользователя, в качестве значений - преобразованные в string посты, в качестве весов - время публикации постов в unix формате.

В ленте пользователя хранятся последние 1000 его друзей. 
При обновлении или удалении отдельного поста автором, он одновременно обновляется или удаляется в лентах подписчиков.
Лента дополняется только при публикации новых постов. 

При запросе на получение ленты конкретным пользователем происходит проверка ее наличия в кэше по ключу.
В случае обнаружении соответствующего ключа, содержимое ленты передается в качестве ответа на запрос.
В случае отсутствия ключа сначала производится инвалидация ленты в кэше, а уже потом ответ на запрос.

Инвалидация кэша производится следующим образом:
- для конкретного пользователя определяются id последних 1000 постов, опубликованных его друзьями
- выбранные для ленты посты получаются из таблицы user_post и преобразуются в формат для хранения в кэше
- лента сохраняется в кэше в виде sorted set с id пользователя в качестве ключа 

Пользователь имеет возможность произвести инвалидацию ленты в кэше самостоятельно.
При этом его текущая лента удаляется и создается заново (cм. выше).


